1. Spring WebFlux

   原先的web 框架包括SpringFramework、SpringWebMVC，是专门为ServletAPI和Servlet容器建造的。而反应栈web架构-SpringWebFlux是在5.0版本之后加入的。它是非阻塞的，支持反应背压，运行在如Netty、Undertow和Servlet3.1+容器上的。两个web框架的源码模块在SpringFramwork上共存并以它们的名称（spring-webmvc和spring-webflux)指代。每个模块都是可选择的。应用可以选择其中一个使用，甚至在某些项目中也可以都使用，例如在SpringMVC controllers 中带有反应器的网络客户端WebClient。

   

   1.1 Overview 简介

   WebFlux缘何成立？（WebFulx的由来）

   一方面是需要用很少的硬件资源和少量线程来非阻塞的处理web堆栈信息。Servlet3.1提供了非阻塞/IO的API。然而它的使用需要避开一些ServletAPI的阻塞场景，例如过滤器，获取参数等。这就为什么需要一个全新的在非阻塞期间运行的公共API的原因。这很重要，因为服务器（如Netty)现在多以在异步和非阻塞空间建立起来。

   另一方面是因为函数式编程。诸如java5加入的注解（REST、单元测试），java8的lambda表达式给java加入了函数式编程的可能。这对于构建非阻塞应用和异步逻辑的可延续的APIs来说是一个福音。在编程模型上，java8为实现Spring WebFlux提供了功能性的web端点和带注释的控制器。

   

   1.1.1 "Reactive"的定义 - "响应式"的定义

   我们了解了“非阻塞”和“函数式”的含义，那么“响应式”又意味着什么呢？

   响应式，这个术语，意味着程序模型是建立响应变化的基础上的：网络组件响应I/O事件，UI控制器响应鼠标事件等等。在那样的场景中，响应是非阻塞的。因为相比于阻塞模式，我们现在可以通过“响应”来完成操作或填充数据。

   另一个Spring团队与“响应式”建立良好机制的原因是非阻塞的后台压力。在同步模式中，发生阻塞时，压力自然而然的导致了因阻塞而等待。而在非阻塞模式，控制事件的效率很重要，所以高压力不会压垮目标服务器。

   响应流是一个小的规范，它定义了在异步组件之间的压力交互。比如说数据库（作为发布者）可以生产数据然后由HTTP服务器（作为订阅者）可以写入响应。相应流主要是让订阅者控制发布者生成数据的速度。


```
    通常来说：如果发布者变慢怎么办？响应流的目的是建立一个反应机制和边界，如果发布者变慢了，响应可以缓存，删除或失败。（而不是阻塞等待超时；这是我加的）

```

   

   

   

   

   

​    

   